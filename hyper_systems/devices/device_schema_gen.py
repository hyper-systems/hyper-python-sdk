"""Generated by atdpy from type definitions in Device_schema.atd.

This implements classes for the types defined in 'Device_schema.atd', providing
methods and functions to convert data from/to JSON.
"""

# Disable flake8 entirely on this file:
# flake8: noqa

# Import annotations to allow forward references
from __future__ import annotations
from dataclasses import dataclass
from typing import Any, Callable, Dict, List, NoReturn, Optional, Tuple, Union

import json

############################################################################
# Private functions
############################################################################


def _atd_missing_json_field(type_name: str, json_field_name: str) -> NoReturn:
    raise ValueError(f"missing field '{json_field_name}'"
                     f" in JSON object of type '{type_name}'")


def _atd_bad_json(expected_type: str, json_value: Any) -> NoReturn:
    value_str = str(json_value)
    if len(value_str) > 200:
        value_str = value_str[:200] + '…'

    raise ValueError(f"incompatible JSON value where"
                     f" type '{expected_type}' was expected: '{value_str}'")


def _atd_bad_python(expected_type: str, json_value: Any) -> NoReturn:
    value_str = str(json_value)
    if len(value_str) > 200:
        value_str = value_str[:200] + '…'

    raise ValueError(f"incompatible Python value where"
                     f" type '{expected_type}' was expected: '{value_str}'")


def _atd_read_unit(x: Any) -> None:
    if x is None:
        return x
    else:
        _atd_bad_json('unit', x)


def _atd_read_bool(x: Any) -> bool:
    if isinstance(x, bool):
        return x
    else:
        _atd_bad_json('bool', x)


def _atd_read_int(x: Any) -> int:
    if isinstance(x, int):
        return x
    else:
        _atd_bad_json('int', x)


def _atd_read_float(x: Any) -> float:
    if isinstance(x, (int, float)):
        return x
    else:
        _atd_bad_json('float', x)


def _atd_read_string(x: Any) -> str:
    if isinstance(x, str):
        return x
    else:
        _atd_bad_json('str', x)


def _atd_read_list(
            read_elt: Callable[[Any], Any]
        ) -> Callable[[List[Any]], List[Any]]:
    def read_list(elts: List[Any]) -> List[Any]:
        if isinstance(elts, list):
            return [read_elt(elt) for elt in elts]
        else:
            _atd_bad_json('array', elts)
    return read_list


def _atd_read_assoc_array_into_dict(
            read_key: Callable[[Any], Any],
            read_value: Callable[[Any], Any],
        ) -> Callable[[List[Any]], Dict[Any, Any]]:
    def read_assoc(elts: List[List[Any]]) -> Dict[str, Any]:
        if isinstance(elts, list):
            return {read_key(elt[0]): read_value(elt[1]) for elt in elts}
        else:
            _atd_bad_json('array', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return read_assoc


def _atd_read_assoc_object_into_dict(
            read_value: Callable[[Any], Any]
        ) -> Callable[[Dict[str, Any]], Dict[str, Any]]:
    def read_assoc(elts: Dict[str, Any]) -> Dict[str, Any]:
        if isinstance(elts, dict):
            return {_atd_read_string(k): read_value(v)
                    for k, v in elts.items()}
        else:
            _atd_bad_json('object', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return read_assoc


def _atd_read_assoc_object_into_list(
            read_value: Callable[[Any], Any]
        ) -> Callable[[Dict[str, Any]], List[Tuple[str, Any]]]:
    def read_assoc(elts: Dict[str, Any]) -> List[Tuple[str, Any]]:
        if isinstance(elts, dict):
            return [(_atd_read_string(k), read_value(v))
                    for k, v in elts.items()]
        else:
            _atd_bad_json('object', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return read_assoc


def _atd_read_nullable(read_elt: Callable[[Any], Any]) \
        -> Callable[[Optional[Any]], Optional[Any]]:
    def read_nullable(x: Any) -> Any:
        if x is None:
            return None
        else:
            return read_elt(x)
    return read_nullable


def _atd_write_unit(x: Any) -> None:
    if x is None:
        return x
    else:
        _atd_bad_python('unit', x)


def _atd_write_bool(x: Any) -> bool:
    if isinstance(x, bool):
        return x
    else:
        _atd_bad_python('bool', x)


def _atd_write_int(x: Any) -> int:
    if isinstance(x, int):
        return x
    else:
        _atd_bad_python('int', x)


def _atd_write_float(x: Any) -> float:
    if isinstance(x, (int, float)):
        return x
    else:
        _atd_bad_python('float', x)


def _atd_write_string(x: Any) -> str:
    if isinstance(x, str):
        return x
    else:
        _atd_bad_python('str', x)


def _atd_write_list(
            write_elt: Callable[[Any], Any]
        ) -> Callable[[List[Any]], List[Any]]:
    def write_list(elts: List[Any]) -> List[Any]:
        if isinstance(elts, list):
            return [write_elt(elt) for elt in elts]
        else:
            _atd_bad_python('list', elts)
    return write_list


def _atd_write_assoc_dict_to_array(
            write_key: Callable[[Any], Any],
            write_value: Callable[[Any], Any]
        ) -> Callable[[Dict[Any, Any]], List[Tuple[Any, Any]]]:
    def write_assoc(elts: Dict[str, Any]) -> List[Tuple[str, Any]]:
        if isinstance(elts, dict):
            return [(write_key(k), write_value(v)) for k, v in elts.items()]
        else:
            _atd_bad_python('Dict[str, <value type>]]', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return write_assoc


def _atd_write_assoc_dict_to_object(
            write_value: Callable[[Any], Any]
        ) -> Callable[[Dict[str, Any]], Dict[str, Any]]:
    def write_assoc(elts: Dict[str, Any]) -> Dict[str, Any]:
        if isinstance(elts, dict):
            return {_atd_write_string(k): write_value(v)
                    for k, v in elts.items()}
        else:
            _atd_bad_python('Dict[str, <value type>]', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return write_assoc


def _atd_write_assoc_list_to_object(
            write_value: Callable[[Any], Any],
        ) -> Callable[[List[Any]], Dict[str, Any]]:
    def write_assoc(elts: List[List[Any]]) -> Dict[str, Any]:
        if isinstance(elts, list):
            return {_atd_write_string(elt[0]): write_value(elt[1])
                    for elt in elts}
        else:
            _atd_bad_python('List[Tuple[<key type>, <value type>]]', elts)
            raise AssertionError('impossible')  # keep mypy happy
    return write_assoc


def _atd_write_nullable(write_elt: Callable[[Any], Any]) \
        -> Callable[[Optional[Any]], Optional[Any]]:
    def write_nullable(x: Any) -> Any:
        if x is None:
            return None
        else:
            return write_elt(x)
    return write_nullable


############################################################################
# Public classes
############################################################################


@dataclass
class Macaddr:
    """Original type: vendor_id_format = [ ... | Macaddr | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Macaddr'

    @staticmethod
    def to_json() -> Any:
        return 'Macaddr'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Imei:
    """Original type: vendor_id_format = [ ... | Imei | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Imei'

    @staticmethod
    def to_json() -> Any:
        return 'Imei'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Decimal:
    """Original type: vendor_id_format = [ ... | Decimal | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Decimal'

    @staticmethod
    def to_json() -> Any:
        return 'Decimal'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Serial:
    """Original type: vendor_id_format = [ ... | Serial | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Serial'

    @staticmethod
    def to_json() -> Any:
        return 'Serial'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class VendorIdFormat:
    """Original type: vendor_id_format = [ ... ]"""

    value: Union[Macaddr, Imei, Decimal, Serial]

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return self.value.kind

    @classmethod
    def from_json(cls, x: Any) -> 'VendorIdFormat':
        if isinstance(x, str):
            if x == 'Macaddr':
                return cls(Macaddr())
            if x == 'Imei':
                return cls(Imei())
            if x == 'Decimal':
                return cls(Decimal())
            if x == 'Serial':
                return cls(Serial())
            _atd_bad_json('VendorIdFormat', x)
        _atd_bad_json('VendorIdFormat', x)

    def to_json(self) -> Any:
        return self.value.to_json()

    @classmethod
    def from_json_string(cls, x: str) -> 'VendorIdFormat':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Time:
    """Original type: time"""

    value: str

    @classmethod
    def from_json(cls, x: Any) -> 'Time':
        return cls(_atd_read_string(x))

    def to_json(self) -> Any:
        return _atd_write_string(self.value)

    @classmethod
    def from_json_string(cls, x: str) -> 'Time':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Json:
    """Original type: json"""

    value: Any

    @classmethod
    def from_json(cls, x: Any) -> 'Json':
        return cls((lambda x: x)(x))

    def to_json(self) -> Any:
        return (lambda x: x)(self.value)

    @classmethod
    def from_json_string(cls, x: str) -> 'Json':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Int8:
    """Original type: device_attribute_format = [ ... | Int8 | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Int8'

    @staticmethod
    def to_json() -> Any:
        return 'Int8'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Int16:
    """Original type: device_attribute_format = [ ... | Int16 | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Int16'

    @staticmethod
    def to_json() -> Any:
        return 'Int16'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Int32:
    """Original type: device_attribute_format = [ ... | Int32 | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Int32'

    @staticmethod
    def to_json() -> Any:
        return 'Int32'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Int64:
    """Original type: device_attribute_format = [ ... | Int64 | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Int64'

    @staticmethod
    def to_json() -> Any:
        return 'Int64'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Uint8:
    """Original type: device_attribute_format = [ ... | Uint8 | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Uint8'

    @staticmethod
    def to_json() -> Any:
        return 'Uint8'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Uint16:
    """Original type: device_attribute_format = [ ... | Uint16 | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Uint16'

    @staticmethod
    def to_json() -> Any:
        return 'Uint16'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Uint32:
    """Original type: device_attribute_format = [ ... | Uint32 | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Uint32'

    @staticmethod
    def to_json() -> Any:
        return 'Uint32'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Uint64:
    """Original type: device_attribute_format = [ ... | Uint64 | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Uint64'

    @staticmethod
    def to_json() -> Any:
        return 'Uint64'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Float32:
    """Original type: device_attribute_format = [ ... | Float32 | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Float32'

    @staticmethod
    def to_json() -> Any:
        return 'Float32'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Float64:
    """Original type: device_attribute_format = [ ... | Float64 | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Float64'

    @staticmethod
    def to_json() -> Any:
        return 'Float64'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Bool:
    """Original type: device_attribute_format = [ ... | Bool | ... ]"""

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Bool'

    @staticmethod
    def to_json() -> Any:
        return 'Bool'

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Data:
    """Original type: device_attribute_format = [ ... | Data of ... | ... ]"""

    value: int

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Data'

    def to_json(self) -> Any:
        return ['Data', _atd_write_int(self.value)]

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Enum:
    """Original type: device_attribute_format = [ ... | Enum of ... | ... ]"""

    value: Dict[str, str]

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return 'Enum'

    def to_json(self) -> Any:
        return ['Enum', _atd_write_assoc_dict_to_object(_atd_write_string)(self.value)]

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class DeviceAttributeFormat:
    """Original type: device_attribute_format = [ ... ]"""

    value: Union[Int8, Int16, Int32, Int64, Uint8, Uint16, Uint32, Uint64, Float32, Float64, Bool, Data, Enum]

    @property
    def kind(self) -> str:
        """Name of the class representing this variant."""
        return self.value.kind

    @classmethod
    def from_json(cls, x: Any) -> 'DeviceAttributeFormat':
        if isinstance(x, str):
            if x == 'Int8':
                return cls(Int8())
            if x == 'Int16':
                return cls(Int16())
            if x == 'Int32':
                return cls(Int32())
            if x == 'Int64':
                return cls(Int64())
            if x == 'Uint8':
                return cls(Uint8())
            if x == 'Uint16':
                return cls(Uint16())
            if x == 'Uint32':
                return cls(Uint32())
            if x == 'Uint64':
                return cls(Uint64())
            if x == 'Float32':
                return cls(Float32())
            if x == 'Float64':
                return cls(Float64())
            if x == 'Bool':
                return cls(Bool())
            _atd_bad_json('DeviceAttributeFormat', x)
        if isinstance(x, List) and len(x) == 2:
            cons = x[0]
            if cons == 'Data':
                return cls(Data(_atd_read_int(x[1])))
            if cons == 'Enum':
                return cls(Enum(_atd_read_assoc_object_into_dict(_atd_read_string)(x[1])))
            _atd_bad_json('DeviceAttributeFormat', x)
        _atd_bad_json('DeviceAttributeFormat', x)

    def to_json(self) -> Any:
        return self.value.to_json()

    @classmethod
    def from_json_string(cls, x: str) -> 'DeviceAttributeFormat':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class Access:
    """Original type: access = { ... }"""

    read: bool
    write: bool

    @classmethod
    def from_json(cls, x: Any) -> 'Access':
        if isinstance(x, dict):
            return cls(
                read=_atd_read_bool(x['read']) if 'read' in x else _atd_missing_json_field('Access', 'read'),
                write=_atd_read_bool(x['write']) if 'write' in x else _atd_missing_json_field('Access', 'write'),
            )
        else:
            _atd_bad_json('Access', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['read'] = _atd_write_bool(self.read)
        res['write'] = _atd_write_bool(self.write)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'Access':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class DeviceAttribute:
    """Original type: device_attribute = { ... }"""

    id: int
    format: DeviceAttributeFormat
    access: Access
    creation_time: Optional[str] = None
    name: Optional[str] = None
    description: Optional[str] = None
    quantity: Optional[str] = None
    unit: Optional[str] = None

    @classmethod
    def from_json(cls, x: Any) -> 'DeviceAttribute':
        if isinstance(x, dict):
            return cls(
                id=_atd_read_int(x['id']) if 'id' in x else _atd_missing_json_field('DeviceAttribute', 'id'),
                format=DeviceAttributeFormat.from_json(x['format']) if 'format' in x else _atd_missing_json_field('DeviceAttribute', 'format'),
                access=Access.from_json(x['access']) if 'access' in x else _atd_missing_json_field('DeviceAttribute', 'access'),
                creation_time=_atd_read_string(x['creation_time']) if 'creation_time' in x else None,
                name=_atd_read_string(x['name']) if 'name' in x else None,
                description=_atd_read_string(x['description']) if 'description' in x else None,
                quantity=_atd_read_string(x['quantity']) if 'quantity' in x else None,
                unit=_atd_read_string(x['unit']) if 'unit' in x else None,
            )
        else:
            _atd_bad_json('DeviceAttribute', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['id'] = _atd_write_int(self.id)
        res['format'] = (lambda x: x.to_json())(self.format)
        res['access'] = (lambda x: x.to_json())(self.access)
        if self.creation_time is not None:
            res['creation_time'] = _atd_write_string(self.creation_time)
        if self.name is not None:
            res['name'] = _atd_write_string(self.name)
        if self.description is not None:
            res['description'] = _atd_write_string(self.description)
        if self.quantity is not None:
            res['quantity'] = _atd_write_string(self.quantity)
        if self.unit is not None:
            res['unit'] = _atd_write_string(self.unit)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'DeviceAttribute':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class DeviceSchema:
    """Original type: device_schema = { ... }"""

    id: int
    vendor_device_id_format: VendorIdFormat
    creation_time: str
    attributes: Dict[str, DeviceAttribute]
    name: Optional[str] = None
    description: Optional[str] = None
    vendor_name: Optional[str] = None

    @classmethod
    def from_json(cls, x: Any) -> 'DeviceSchema':
        if isinstance(x, dict):
            return cls(
                id=_atd_read_int(x['id']) if 'id' in x else _atd_missing_json_field('DeviceSchema', 'id'),
                vendor_device_id_format=VendorIdFormat.from_json(x['vendor_device_id_format']) if 'vendor_device_id_format' in x else _atd_missing_json_field('DeviceSchema', 'vendor_device_id_format'),
                creation_time=_atd_read_string(x['creation_time']) if 'creation_time' in x else _atd_missing_json_field('DeviceSchema', 'creation_time'),
                attributes=_atd_read_assoc_object_into_dict(DeviceAttribute.from_json)(x['attributes']) if 'attributes' in x else _atd_missing_json_field('DeviceSchema', 'attributes'),
                name=_atd_read_string(x['name']) if 'name' in x else None,
                description=_atd_read_string(x['description']) if 'description' in x else None,
                vendor_name=_atd_read_string(x['vendor_name']) if 'vendor_name' in x else None,
            )
        else:
            _atd_bad_json('DeviceSchema', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['id'] = _atd_write_int(self.id)
        res['vendor_device_id_format'] = (lambda x: x.to_json())(self.vendor_device_id_format)
        res['creation_time'] = _atd_write_string(self.creation_time)
        res['attributes'] = _atd_write_assoc_dict_to_object((lambda x: x.to_json()))(self.attributes)
        if self.name is not None:
            res['name'] = _atd_write_string(self.name)
        if self.description is not None:
            res['description'] = _atd_write_string(self.description)
        if self.vendor_name is not None:
            res['vendor_name'] = _atd_write_string(self.vendor_name)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'DeviceSchema':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class DeviceMessage:
    """Original type: device_message = { ... }"""

    message_uuid: str
    created_time: Time
    vendor_device_id: str
    device_class_id: int
    values: Dict[str, Json]

    @classmethod
    def from_json(cls, x: Any) -> 'DeviceMessage':
        if isinstance(x, dict):
            return cls(
                message_uuid=_atd_read_string(x['message_uuid']) if 'message_uuid' in x else _atd_missing_json_field('DeviceMessage', 'message_uuid'),
                created_time=Time.from_json(x['created_time']) if 'created_time' in x else _atd_missing_json_field('DeviceMessage', 'created_time'),
                vendor_device_id=_atd_read_string(x['vendor_device_id']) if 'vendor_device_id' in x else _atd_missing_json_field('DeviceMessage', 'vendor_device_id'),
                device_class_id=_atd_read_int(x['device_class_id']) if 'device_class_id' in x else _atd_missing_json_field('DeviceMessage', 'device_class_id'),
                values=_atd_read_assoc_object_into_dict(Json.from_json)(x['values']) if 'values' in x else _atd_missing_json_field('DeviceMessage', 'values'),
            )
        else:
            _atd_bad_json('DeviceMessage', x)

    def to_json(self) -> Any:
        res: Dict[str, Any] = {}
        res['message_uuid'] = _atd_write_string(self.message_uuid)
        res['created_time'] = (lambda x: x.to_json())(self.created_time)
        res['vendor_device_id'] = _atd_write_string(self.vendor_device_id)
        res['device_class_id'] = _atd_write_int(self.device_class_id)
        res['values'] = _atd_write_assoc_dict_to_object((lambda x: x.to_json()))(self.values)
        return res

    @classmethod
    def from_json_string(cls, x: str) -> 'DeviceMessage':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)


@dataclass
class DeviceMessageList:
    """Original type: device_message_list"""

    value: List[DeviceMessage]

    @classmethod
    def from_json(cls, x: Any) -> 'DeviceMessageList':
        return cls(_atd_read_list(DeviceMessage.from_json)(x))

    def to_json(self) -> Any:
        return _atd_write_list((lambda x: x.to_json()))(self.value)

    @classmethod
    def from_json_string(cls, x: str) -> 'DeviceMessageList':
        return cls.from_json(json.loads(x))

    def to_json_string(self, **kw: Any) -> str:
        return json.dumps(self.to_json(), **kw)
